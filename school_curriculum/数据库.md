## 数据库

### 第5章 关系数据理论与模式求精

#### 0.0学习目标

从“==构造一个好的关系模式==”出发，深入介绍基于**函数依赖**的关系数据库规范化理论和方法，包括“函数依赖定义、函数依赖集理论、范式定义及分解算法”。学习目标为熟练掌握**函数依赖和关系数据库各种范式的基本概念和定义**，并能运用**基本函数依赖理论对**==关系模式逐步求精==，以满足最终应用需求。

#### 0.1学习方法

​      1.根据现实世界中数据的语义理解函数依赖的概念

​      2.结合实例，理解部分依赖和传递依赖带来的关系模式异常问题

​      3.实践联系，在函数依赖的理论指导下对给定的关系模式进行范式分解

#### 5.1问题提出

- 什么样的数据库模式是一个“好”的模式？

- 又怎么设计出一个“好”的模式？

##### 1.数据冗余造成的问题：

<img src="C:/Users/24987/AppData/Local/Temp/WeChat Files/eaa4a9dd46631ddd5488503e084e73f.jpg" alt="eaa4a9dd46631ddd5488503e084e73f" style="zoom:20%;" />

指同一信息在数据库中存储了多个副本（如上）studentNo和courseNo是唯一候选码也是主码。

- 冗余存储：姓名和课程名
- 更新异常：修改姓名或课程名只改了部分
- 插入异常：若学生未选修课程或课程没有学生选，就无法存入数据库
- 删除异常：当学生所有课程被删了，那么学生信息会丢失，课程同理

**原因分析**：该模式属性间存在依赖关系，导致数据冗余（学生姓名依赖于学号，课程名依赖于课程号，成绩依赖于学号和课程号）。如果将SCE分成3张表S,C,E,3种依赖关系分别分解到每个单独的关系模式中，就能解决问题了。



##### 2.模式分解导致的问题

思考：什么样的需要进一步分解？是否所有的分解都是有益的？

<img src="C:\Users\24987\AppData\Roaming\Typora\typora-user-images\image-20230511110007121.png" alt="image-20230511110007121" style="zoom:20%;" />

<img src="C:\Users\24987\AppData\Roaming\Typora\typora-user-images\image-20230511110026154.png" alt="image-20230511110026154" style="zoom:20%;" />

过度分解会导致有信息缺失，即有损分解，并且依赖关系也消失。

所以好的分解要做到**无损连接和保持依赖**。



#### 5.2 函数依赖定义

##### 5.2.1函数依赖

<img src="C:/Users/24987/AppData/Local/Temp/WeChat Files/d77b72c68eb7f28744e9a2e7797f460.jpg" alt="d77b72c68eb7f28744e9a2e7797f460" style="zoom:25%;" />
$$
\alpha\to\beta 表示\alpha函数确定\beta,或\beta函数依赖于\alpha
$$
说明：1.函数依赖是指r(R)的所有关系都要满足的约束条件；

​            2.**α->β，当α相同时，β一定是相同的**

##### 5.2.2 平凡与非平凡函数依赖

<img src="C:/Users/24987/AppData/Local/Temp/WeChat Files/2ed5afd6ff92092a6f5a27a0e2822b1.jpg" alt="2ed5afd6ff92092a6f5a27a0e2822b1" style="zoom:25%;" />

区别在于β是否属于α。

##### 5.2.3完全函数依赖和部分函数依赖

<img src="C:/Users/24987/AppData/Local/Temp/WeChat Files/9158b7869fa4adf26f147586fcbd56d.jpg" alt="9158b7869fa4adf26f147586fcbd56d" style="zoom:25%;" />

完全函数依赖是指不存在这样的γ，即α已经是“最小”的了。

##### 5.2.4传递函数依赖

##### <img src="C:/Users/24987/AppData/Local/Temp/WeChat Files/042b8afd3dc8a3b834f44ab5ca30b4f.jpg" alt="042b8afd3dc8a3b834f44ab5ca30b4f" style="zoom:25%;" />

会造成数据冗余

#### 5.3范式(越来越严格)

##### 5.3.1 第一范式（1NF）码

定义：属性域值不可分（原子项）

##### 5.3.2 第二范式（2NF） 全部是码

定义：**所有非主属性都完全函数依赖于候选码**。即依赖于全部的候选码属性。

例子：SCE中学生姓名依赖于学号，课程名依赖于课程号，但候选码由学号和课程号共同组成，所以存在部分依赖，不满足第二范式

如果候选码只有单个属性，一定满足第二范式（在第一范式基础上）；

没有解决传递依赖的问题

##### 5.3.3 第三范式（3NF) 仅仅是码

定义：在第二范式基础上，**所有非主属性都（只能）（仅仅是码）直接函数依赖于全部的（第二范式）候选码**（即不存在非主属性传递依赖于候选码）

若不存在非主属性，那么一定满足第三范式

对于非3NF的关系模式，可以通过分解进行规范化

##### 5.3.4 Boyce-Codd范式（BCNF)

<img src="C:/Users/24987/AppData/Local/Temp/WeChat Files/0a24a3e62374ac881cf9a40912feade.jpg" alt="0a24a3e62374ac881cf9a40912feade" style="zoom:20%;" />



- 所有非主属性都完全函数依赖于**每个**候选码
- 所有主属性都完全函数依赖于**每个**不包含它的候选码
- 没有任何属性完全函数依赖于非候选码的任何一组属性

<img src="C:/Users/24987/AppData/Local/Temp/WeChat Files/4b2fc2164afdba8c30b30fca1eb105a.jpg" alt="4b2fc2164afdba8c30b30fca1eb105a" style="zoom:20%;" />

- 满足BCNF,不一定满足保持依赖分解

3NF和BCNF比较：

- 3NF相对于BCNF的放松值处在于允许存在主属性对候选码的传递依赖和部分依赖
- 3NF存在信息冗余和异常，BCNF不存在
- BCNF是无损分解，但不一定是保持依赖分解；3NF既是无损分解，又是保持依赖分解。

